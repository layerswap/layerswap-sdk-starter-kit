/// <reference types="node" />
import { Configuration, ApplicationOut, ListResponseApplicationOut, ApplicationIn, ListResponseEndpointOut, EndpointOut, EndpointIn, EndpointUpdate, EndpointSecretOut, EndpointSecretRotateIn, EndpointTransformationIn, EndpointTransformationOut, EndpointHeadersIn, EndpointHeadersPatchIn, EndpointHeadersOut, EndpointStats, EventExampleIn, RecoverIn, ReplayIn, ListResponseIntegrationOut, IntegrationOut, IntegrationIn, IntegrationUpdate, IntegrationKeyOut, MessageOut, MessageIn, ListResponseMessageOut, DashboardAccessOut, ListResponseEndpointMessageOut, ListResponseMessageEndpointOut, ListResponseMessageAttemptEndpointOut, ListResponseMessageAttemptOut, MessageAttemptOut, MessageStatus, ListResponseEventTypeOut, EventTypeIn, EventTypeOut, EventTypeUpdate, StatusCodeClass, AppPortalAccessOut, AppPortalAccessIn, Ordering, BackgroundTaskStatus, BackgroundTaskType, BackgroundTaskOut, ListResponseBackgroundTaskOut } from "./openapi/index";
export * from "./openapi/models/all";
export * from "./openapi/apis/exception";
export interface SvixOptions {
    debug?: boolean;
    serverUrl?: string;
}
export declare class Svix {
    readonly _configuration: Configuration;
    readonly authentication: Authentication;
    readonly application: Application;
    readonly endpoint: Endpoint;
    readonly eventType: EventType;
    readonly integration: Integration;
    readonly message: Message;
    readonly messageAttempt: MessageAttempt;
    readonly backgroundTask: BackgroundTask;
    constructor(token: string, options?: SvixOptions);
}
export interface PostOptions {
    idempotencyKey?: string;
}
declare class Authentication {
    private readonly api;
    constructor(config: Configuration);
    appPortalAccess(appId: string, appPortalAccessIn: AppPortalAccessIn, options?: PostOptions): Promise<AppPortalAccessOut>;
    dashboardAccess(appId: string, options?: PostOptions): Promise<DashboardAccessOut>;
    logout(options?: PostOptions): Promise<void>;
}
interface ListOptions {
    iterator?: string;
    limit?: number;
}
export interface ApplicationListOptions extends ListOptions {
    order?: Ordering;
}
export interface EndpointListOptions extends ListOptions {
    order?: Ordering;
}
export interface EndpointStatsOptions {
    since?: Date;
    until?: Date;
}
export declare type IntegrationListOptions = ListOptions;
export interface EventTypeListOptions extends ListOptions {
    withContent?: boolean;
    includeArchived?: boolean;
}
export interface MessageListOptions extends ListOptions {
    eventTypes?: string[];
    before?: Date;
    after?: Date;
    channel?: string;
    withContent?: boolean;
}
export interface MessageAttemptListOptions extends ListOptions {
    status?: MessageStatus;
    eventTypes?: string[];
    before?: Date;
    after?: Date;
    statusCodeClass?: StatusCodeClass;
    channel?: string;
}
export interface BackgroundTaskListOptions extends ListOptions {
    status?: BackgroundTaskStatus;
    task?: BackgroundTaskType;
}
declare class Application {
    private readonly api;
    constructor(config: Configuration);
    list(options?: ApplicationListOptions): Promise<ListResponseApplicationOut>;
    create(applicationIn: ApplicationIn, options?: PostOptions): Promise<ApplicationOut>;
    getOrCreate(applicationIn: ApplicationIn, options?: PostOptions): Promise<ApplicationOut>;
    get(appId: string): Promise<ApplicationOut>;
    update(appId: string, applicationIn: ApplicationIn): Promise<ApplicationOut>;
    delete(appId: string): Promise<void>;
}
declare class Endpoint {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: EndpointListOptions): Promise<ListResponseEndpointOut>;
    create(appId: string, endpointIn: EndpointIn, options?: PostOptions): Promise<EndpointOut>;
    get(appId: string, endpointId: string): Promise<EndpointOut>;
    update(appId: string, endpointId: string, endpointUpdate: EndpointUpdate): Promise<EndpointOut>;
    delete(appId: string, endpointId: string): Promise<void>;
    getSecret(appId: string, endpointId: string): Promise<EndpointSecretOut>;
    rotateSecret(appId: string, endpointId: string, endpointSecretRotateIn: EndpointSecretRotateIn, options?: PostOptions): Promise<void>;
    recover(appId: string, endpointId: string, recoverIn: RecoverIn, options?: PostOptions): Promise<void>;
    replayMissing(appId: string, endpointId: string, replayIn: ReplayIn, options?: PostOptions): Promise<void>;
    getHeaders(appId: string, endpointId: string): Promise<EndpointHeadersOut>;
    updateHeaders(appId: string, endpointId: string, endpointHeadersIn: EndpointHeadersIn): Promise<void>;
    patchHeaders(appId: string, endpointId: string, endpointHeadersPatchIn: EndpointHeadersPatchIn): Promise<void>;
    getStats(appId: string, endpointId: string, options?: EndpointStatsOptions): Promise<EndpointStats>;
    transformationGet(appId: string, endpointId: string): Promise<EndpointTransformationOut>;
    transformationPartialUpdate(appId: string, endpointId: string, endpointTransformationIn: EndpointTransformationIn): Promise<void>;
    sendExample(appId: string, endpointId: string, eventExampleIn: EventExampleIn, options?: PostOptions): Promise<MessageOut>;
}
declare class EventType {
    private readonly api;
    constructor(config: Configuration);
    list(options?: EventTypeListOptions): Promise<ListResponseEventTypeOut>;
    get(eventTypeName: string): Promise<EventTypeOut>;
    create(eventTypeIn: EventTypeIn, options?: PostOptions): Promise<EventTypeOut>;
    update(eventTypeName: string, eventTypeUpdate: EventTypeUpdate): Promise<EventTypeOut>;
    delete(eventTypeName: string): Promise<void>;
}
declare class Integration {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: IntegrationListOptions): Promise<ListResponseIntegrationOut>;
    create(appId: string, integrationIn: IntegrationIn, options?: PostOptions): Promise<IntegrationOut>;
    get(appId: string, integId: string): Promise<IntegrationOut>;
    update(appId: string, integId: string, integrationUpdate: IntegrationUpdate): Promise<IntegrationOut>;
    delete(appId: string, integId: string): Promise<void>;
    getKey(appId: string, integId: string): Promise<IntegrationKeyOut>;
    rotateKey(appId: string, integId: string, options?: PostOptions): Promise<IntegrationKeyOut>;
}
declare class Message {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, options?: MessageListOptions): Promise<ListResponseMessageOut>;
    create(appId: string, messageIn: MessageIn, options?: PostOptions): Promise<MessageOut>;
    get(appId: string, msgId: string): Promise<MessageOut>;
    expungeContent(appId: string, msgId: string): Promise<void>;
}
declare class MessageAttempt {
    private readonly api;
    constructor(config: Configuration);
    list(appId: string, msgId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageAttemptOut>;
    listByMsg(appId: string, msgId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageAttemptOut>;
    listByEndpoint(appId: string, endpointId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageAttemptOut>;
    get(appId: string, msgId: string, attemptId: string): Promise<MessageAttemptOut>;
    resend(appId: string, msgId: string, endpointId: string, options?: PostOptions): Promise<void>;
    listAttemptedMessages(appId: string, endpointId: string, options?: MessageAttemptListOptions): Promise<ListResponseEndpointMessageOut>;
    listAttemptedDestinations(appId: string, msgId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageEndpointOut>;
    listAttemptsForEndpoint(appId: string, msgId: string, endpointId: string, options?: MessageAttemptListOptions): Promise<ListResponseMessageAttemptEndpointOut>;
    expungeContent(appId: string, msgId: string, attemptId: string): Promise<void>;
}
declare class BackgroundTask {
    private readonly api;
    constructor(config: Configuration);
    listByEndpoint(options?: BackgroundTaskListOptions): Promise<ListResponseBackgroundTaskOut>;
    get(taskId: string): Promise<BackgroundTaskOut>;
}
declare class ExtendableError extends Error {
    constructor(message: any);
}
export declare class WebhookVerificationError extends ExtendableError {
    constructor(message: string);
}
export interface WebhookRequiredHeaders {
    "svix-id": string;
    "svix-timestamp": string;
    "svix-signature": string;
}
export interface WebhookUnbrandedRequiredHeaders {
    "webhook-id": string;
    "webhook-timestamp": string;
    "webhook-signature": string;
}
export interface WebhookOptions {
    format?: "raw";
}
export declare class Webhook {
    private static prefix;
    private readonly key;
    constructor(secret: string | Uint8Array, options?: WebhookOptions);
    verify(payload: string | Buffer, headers_: WebhookRequiredHeaders | WebhookUnbrandedRequiredHeaders | Record<string, string>): unknown;
    sign(msgId: string, timestamp: Date, payload: string | Buffer): string;
    private verifyTimestamp;
}
