"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = exports.WebhookVerificationError = exports.Svix = void 0;
const index_1 = require("./openapi/index");
__exportStar(require("./openapi/models/all"), exports);
__exportStar(require("./openapi/apis/exception"), exports);
const timing_safe_equal_1 = require("./timing_safe_equal");
const base64 = require("@stablelib/base64");
const sha256 = require("fast-sha256");
const WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
const VERSION = "1.5.2";
class UserAgentMiddleware {
    pre(context) {
        context.setHeaderParam("User-Agent", `svix-libs/${VERSION}/javascript`);
        return Promise.resolve(context);
    }
    post(context) {
        return Promise.resolve(context);
    }
}
const REGIONS = [
    { region: "us", url: "https://api.us.svix.com" },
    { region: "eu", url: "https://api.eu.svix.com" },
    { region: "in", url: "https://api.in.svix.com" },
];
class Svix {
    constructor(token, options = {}) {
        var _a, _b, _c;
        const regionalUrl = (_a = REGIONS.find((x) => x.region === token.split(".")[1])) === null || _a === void 0 ? void 0 : _a.url;
        const baseUrl = (_c = (_b = options.serverUrl) !== null && _b !== void 0 ? _b : regionalUrl) !== null && _c !== void 0 ? _c : "https://api.svix.com";
        const baseServer = new index_1.ServerConfiguration(baseUrl, {});
        const bearerConfiguration = {
            tokenProvider: {
                getToken: () => token,
            },
        };
        const config = index_1.createConfiguration({
            baseServer,
            promiseMiddleware: [new UserAgentMiddleware()],
            authMethods: {
                HTTPBearer: bearerConfiguration,
            },
        });
        this._configuration = config;
        this.authentication = new Authentication(config);
        this.application = new Application(config);
        this.endpoint = new Endpoint(config);
        this.eventType = new EventType(config);
        this.integration = new Integration(config);
        this.message = new Message(config);
        this.messageAttempt = new MessageAttempt(config);
        this.backgroundTask = new BackgroundTask(config);
    }
}
exports.Svix = Svix;
class Authentication {
    constructor(config) {
        this.api = new index_1.AuthenticationApi(config);
    }
    appPortalAccess(appId, appPortalAccessIn, options) {
        return this.api.v1AuthenticationAppPortalAccess(Object.assign({ appId,
            appPortalAccessIn }, options));
    }
    dashboardAccess(appId, options) {
        return this.api.v1AuthenticationDashboardAccess(Object.assign({ appId }, options));
    }
    logout(options) {
        return this.api.v1AuthenticationLogout(Object.assign({}, options));
    }
}
class Application {
    constructor(config) {
        this.api = new index_1.ApplicationApi(config);
    }
    list(options) {
        return this.api.v1ApplicationList(Object.assign({}, options));
    }
    create(applicationIn, options) {
        return this.api.v1ApplicationCreate(Object.assign({ applicationIn }, options));
    }
    getOrCreate(applicationIn, options) {
        return this.api.v1ApplicationCreate(Object.assign(Object.assign({ applicationIn }, options), { getIfExists: true }));
    }
    get(appId) {
        return this.api.v1ApplicationGet({ appId });
    }
    update(appId, applicationIn) {
        return this.api.v1ApplicationUpdate({ appId, applicationIn });
    }
    delete(appId) {
        return this.api.v1ApplicationDelete({ appId });
    }
}
class Endpoint {
    constructor(config) {
        this.api = new index_1.EndpointApi(config);
    }
    list(appId, options) {
        return this.api.v1EndpointList(Object.assign({ appId }, options));
    }
    create(appId, endpointIn, options) {
        return this.api.v1EndpointCreate(Object.assign({ appId,
            endpointIn }, options));
    }
    get(appId, endpointId) {
        return this.api.v1EndpointGet({ endpointId, appId });
    }
    update(appId, endpointId, endpointUpdate) {
        return this.api.v1EndpointUpdate({
            appId,
            endpointId,
            endpointUpdate,
        });
    }
    delete(appId, endpointId) {
        return this.api.v1EndpointDelete({
            endpointId,
            appId,
        });
    }
    getSecret(appId, endpointId) {
        return this.api.v1EndpointGetSecret({
            endpointId,
            appId,
        });
    }
    rotateSecret(appId, endpointId, endpointSecretRotateIn, options) {
        return this.api.v1EndpointRotateSecret(Object.assign({ endpointId,
            appId,
            endpointSecretRotateIn }, options));
    }
    recover(appId, endpointId, recoverIn, options) {
        return this.api
            .v1EndpointRecover(Object.assign({ appId,
            endpointId,
            recoverIn }, options))
            .then(() => Promise.resolve());
    }
    replayMissing(appId, endpointId, replayIn, options) {
        return this.api
            .v1EndpointReplay(Object.assign({ appId,
            endpointId,
            replayIn }, options))
            .then(() => Promise.resolve());
    }
    getHeaders(appId, endpointId) {
        return this.api.v1EndpointGetHeaders({
            appId,
            endpointId,
        });
    }
    updateHeaders(appId, endpointId, endpointHeadersIn) {
        return this.api.v1EndpointUpdateHeaders({
            appId,
            endpointId,
            endpointHeadersIn,
        });
    }
    patchHeaders(appId, endpointId, endpointHeadersPatchIn) {
        return this.api.v1EndpointPatchHeaders({
            appId,
            endpointId,
            endpointHeadersPatchIn,
        });
    }
    getStats(appId, endpointId, options) {
        return this.api.v1EndpointGetStats(Object.assign({ appId,
            endpointId }, options));
    }
    transformationGet(appId, endpointId) {
        return this.api.v1EndpointTransformationGet({ endpointId, appId });
    }
    transformationPartialUpdate(appId, endpointId, endpointTransformationIn) {
        return this.api.v1EndpointTransformationPartialUpdate({ appId, endpointId, endpointTransformationIn });
    }
    sendExample(appId, endpointId, eventExampleIn, options) {
        return this.api.v1EndpointSendExample(Object.assign({ appId, endpointId, eventExampleIn }, options));
    }
}
class EventType {
    constructor(config) {
        this.api = new index_1.EventTypeApi(config);
    }
    list(options) {
        return this.api.v1EventTypeList(Object.assign({}, options));
    }
    get(eventTypeName) {
        return this.api.v1EventTypeGet({ eventTypeName });
    }
    create(eventTypeIn, options) {
        return this.api.v1EventTypeCreate(Object.assign({ eventTypeIn }, options));
    }
    update(eventTypeName, eventTypeUpdate) {
        return this.api.v1EventTypeUpdate({
            eventTypeName,
            eventTypeUpdate,
        });
    }
    delete(eventTypeName) {
        return this.api.v1EventTypeDelete({ eventTypeName });
    }
}
class Integration {
    constructor(config) {
        this.api = new index_1.IntegrationApi(config);
    }
    list(appId, options) {
        return this.api.v1IntegrationList(Object.assign({ appId }, options));
    }
    create(appId, integrationIn, options) {
        return this.api.v1IntegrationCreate(Object.assign({ appId,
            integrationIn }, options));
    }
    get(appId, integId) {
        return this.api.v1IntegrationGet({ integId, appId });
    }
    update(appId, integId, integrationUpdate) {
        return this.api.v1IntegrationUpdate({
            appId,
            integId,
            integrationUpdate,
        });
    }
    delete(appId, integId) {
        return this.api.v1IntegrationDelete({
            integId,
            appId,
        });
    }
    getKey(appId, integId) {
        return this.api.v1IntegrationGetKey({
            integId,
            appId,
        });
    }
    rotateKey(appId, integId, options) {
        return this.api.v1IntegrationRotateKey(Object.assign({ integId,
            appId }, options));
    }
}
class Message {
    constructor(config) {
        this.api = new index_1.MessageApi(config);
    }
    list(appId, options) {
        return this.api.v1MessageList(Object.assign({ appId }, options));
    }
    create(appId, messageIn, options) {
        return this.api.v1MessageCreate(Object.assign({ appId, messageIn }, options));
    }
    get(appId, msgId) {
        return this.api.v1MessageGet({ msgId, appId });
    }
    expungeContent(appId, msgId) {
        return this.api.v1MessageExpungeContent({ appId, msgId });
    }
}
class MessageAttempt {
    constructor(config) {
        this.api = new index_1.MessageAttemptApi(config);
    }
    list(appId, msgId, options) {
        return this.listByMsg(appId, msgId, options);
    }
    listByMsg(appId, msgId, options) {
        return this.api.v1MessageAttemptListByMsg(Object.assign({ appId,
            msgId }, options));
    }
    listByEndpoint(appId, endpointId, options) {
        return this.api.v1MessageAttemptListByEndpoint(Object.assign({ appId,
            endpointId }, options));
    }
    get(appId, msgId, attemptId) {
        return this.api.v1MessageAttemptGet({
            attemptId,
            msgId,
            appId,
        });
    }
    resend(appId, msgId, endpointId, options) {
        return this.api.v1MessageAttemptResend(Object.assign({ endpointId,
            msgId,
            appId }, options));
    }
    listAttemptedMessages(appId, endpointId, options) {
        return this.api.v1MessageAttemptListAttemptedMessages(Object.assign({ appId,
            endpointId }, options));
    }
    listAttemptedDestinations(appId, msgId, options) {
        return this.api.v1MessageAttemptListAttemptedDestinations(Object.assign({ appId,
            msgId }, options));
    }
    listAttemptsForEndpoint(appId, msgId, endpointId, options) {
        return this.api.v1MessageAttemptListByEndpointDeprecated(Object.assign({ appId, msgId, endpointId }, options));
    }
    expungeContent(appId, msgId, attemptId) {
        return this.api.v1MessageAttemptExpungeContent({
            appId, msgId, attemptId
        });
    }
}
class BackgroundTask {
    constructor(config) {
        this.api = new index_1.BackgroundTasksApi(config);
    }
    listByEndpoint(options) {
        return this.api.listBackgroundTasks(Object.assign({}, options));
    }
    get(taskId) {
        return this.api.getBackgroundTask({
            taskId
        });
    }
}
class ExtendableError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, ExtendableError.prototype);
        this.name = "ExtendableError";
        this.stack = new Error(message).stack;
    }
}
class WebhookVerificationError extends ExtendableError {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, WebhookVerificationError.prototype);
        this.name = "WebhookVerificationError";
    }
}
exports.WebhookVerificationError = WebhookVerificationError;
class Webhook {
    constructor(secret, options) {
        if (!secret) {
            throw new Error("Secret can't be empty.");
        }
        if ((options === null || options === void 0 ? void 0 : options.format) === "raw") {
            if (secret instanceof Uint8Array) {
                this.key = secret;
            }
            else {
                this.key = Uint8Array.from(secret, (c) => c.charCodeAt(0));
            }
        }
        else {
            if (typeof secret !== "string") {
                throw new Error("Expected secret to be of type string");
            }
            if (secret.startsWith(Webhook.prefix)) {
                secret = secret.substring(Webhook.prefix.length);
            }
            this.key = base64.decode(secret);
        }
    }
    verify(payload, headers_) {
        const headers = {};
        for (const key of Object.keys(headers_)) {
            headers[key.toLowerCase()] = headers_[key];
        }
        let msgId = headers["svix-id"];
        let msgSignature = headers["svix-signature"];
        let msgTimestamp = headers["svix-timestamp"];
        if (!msgSignature || !msgId || !msgTimestamp) {
            msgId = headers["webhook-id"];
            msgSignature = headers["webhook-signature"];
            msgTimestamp = headers["webhook-timestamp"];
            if (!msgSignature || !msgId || !msgTimestamp) {
                throw new WebhookVerificationError("Missing required headers");
            }
        }
        const timestamp = this.verifyTimestamp(msgTimestamp);
        const computedSignature = this.sign(msgId, timestamp, payload);
        const expectedSignature = computedSignature.split(",")[1];
        const passedSignatures = msgSignature.split(" ");
        const encoder = new globalThis.TextEncoder();
        for (const versionedSignature of passedSignatures) {
            const [version, signature] = versionedSignature.split(",");
            if (version !== "v1") {
                continue;
            }
            if (timing_safe_equal_1.timingSafeEqual(encoder.encode(signature), encoder.encode(expectedSignature))) {
                return JSON.parse(payload.toString());
            }
        }
        throw new WebhookVerificationError("No matching signature found");
    }
    sign(msgId, timestamp, payload) {
        if (typeof payload === "string") {
        }
        else if (payload.constructor.name === "Buffer") {
            payload = payload.toString();
        }
        else {
            throw new Error("Expected payload to be of type string or Buffer. Please refer to https://docs.svix.com/receiving/verifying-payloads/how for more information.");
        }
        const encoder = new TextEncoder();
        const timestampNumber = Math.floor(timestamp.getTime() / 1000);
        const toSign = encoder.encode(`${msgId}.${timestampNumber}.${payload}`);
        const expectedSignature = base64.encode(sha256.hmac(this.key, toSign));
        return `v1,${expectedSignature}`;
    }
    verifyTimestamp(timestampHeader) {
        const now = Math.floor(Date.now() / 1000);
        const timestamp = parseInt(timestampHeader, 10);
        if (isNaN(timestamp)) {
            throw new WebhookVerificationError("Invalid Signature Headers");
        }
        if (now - timestamp > WEBHOOK_TOLERANCE_IN_SECONDS) {
            throw new WebhookVerificationError("Message timestamp too old");
        }
        if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
            throw new WebhookVerificationError("Message timestamp too new");
        }
        return new Date(timestamp * 1000);
    }
}
exports.Webhook = Webhook;
Webhook.prefix = "whsec_";
//# sourceMappingURL=index.js.map