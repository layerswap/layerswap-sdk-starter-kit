"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsomorphicFetchHttpLibrary = void 0;
const http_1 = require("./http");
const rxjsStub_1 = require("../rxjsStub");
require("svix-fetch");
const numRetries = 2;
const sleep = (interval) => new Promise(resolve => setTimeout(resolve, interval));
class IsomorphicFetchHttpLibrary {
    send(request) {
        const resultPromise = this.sendWithRetry(request, numRetries, 50, 1);
        return rxjsStub_1.from(resultPromise);
    }
    sendWithRetry(request, triesLeft, nextInterval, retryCount) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.sendOnce(request);
                if (triesLeft <= 0 || response.httpStatusCode < 500) {
                    return response;
                }
            }
            catch (e) {
                if (triesLeft <= 0) {
                    throw e;
                }
            }
            ;
            yield sleep(nextInterval);
            const headers = request.getHeaders();
            headers['svix-retry-count'] = retryCount.toString();
            return yield this.sendWithRetry(request, --triesLeft, nextInterval * 2, ++retryCount);
        });
    }
    sendOnce(request) {
        let method = request.getHttpMethod().toString();
        let body = request.getBody();
        return fetch(request.getUrl(), {
            method: method,
            body: body,
            headers: request.getHeaders(),
            credentials: "same-origin"
        }).then((resp) => {
            const headers = {};
            resp.headers.forEach((value, name) => {
                headers[name] = value;
            });
            const body = {
                text: () => resp.text(),
                binary: () => resp.blob()
            };
            return new http_1.ResponseContext(resp.status, headers, body);
        });
    }
}
exports.IsomorphicFetchHttpLibrary = IsomorphicFetchHttpLibrary;
//# sourceMappingURL=isomorphic-fetch.js.map